# MoneyMarket contains high level values that are changed by governance
# Dapp note - Gross borrow and Gross supply can be solved with Javascript front end
type MoneyMarket @entity {
    id: ID! # just set to 1

    # Event NewRiskParameters
    collateralRatioMantissa: BigInt!        # 1.5x needed
    liquidationDiscountMantissa: BigInt!    # liquidating user gets your 5%

    # Event NewOriginationFee
    originationFeeMantissa: BigInt!         # 0.25% to instantiate a borrow
}

# Dapp note - marketLiquidity, and sponsorEquity can be queried by the front ent
# Note that the supplyRateMantissa and borrowRateMantissa are the per block return on an asset borrowed/supplied
type Market @entity {
    id: ID!                     # asset address
    assetName: String!
    isSupported: Boolean!
    isSuspended: Boolean!       # not part of main struct, must get from event SuspendedMarket (note, has never been emitted on mainnet yet)
    blockNumber: BigInt!        # block number the market is updated to, which is the last block a trade on this market occurred
    interestRateModel: Bytes!   # address of the interestRateModel contract
    totalSupply: BigInt!        # includes all decimal points. Usually 10^-18, but not always, depends on how many decimal places the asset has
    supplyRateMantissa: BigInt! # to get APR : supplyRateMantissa * 2102400 * 10 ^-18
    supplyIndex: BigInt!        # The history of the markets supplyindex return since inception. (Think S&P 500)
    totalBorrows: BigInt!       # includes all decimal points. Usually 10^-18, but not always
    borrowRateMantissa: BigInt! # to get APR : supplyRateMantissa * 2102400 * 10 ^-18, but not always, depends on how many decimal places the asset has
    borrowIndex: BigInt!        # The history of the markets borrow index return since inception. (Think S&P 500)

}

type User @entity {
    id: ID! # user eth address
    assets: [Asset!]! @derivedFrom(field: "user") # derivedFrom will allow all Asset entities to show up for the User
}

type Asset @entity {
    id: ID!                             # concatenation of the asset name and user eth address (i.e. DAI-0xdA5d.......)
    user: Bytes!                        # user address for look up
    supplyPrincipal: BigInt
    supplyInterestLastChange: BigInt    # is only updated to the last event, event SupplyReceived and event SupplyWithdrawn. i.e. Per block interest isn't saved, since the blockchain also does not store this.
    totalSupplyInterest: BigInt         # adds together each round of borrowed asset, to record a cumulative amount, since it isn't stored anywhere in the smart contract (actual asset value, i.e. not a percentage)
    supplyInterestIndex: BigInt         # The users personal return in supplying the asset (5.23% would be 1.05230 * 10^18)
    borrowPrincipal: BigInt
    borrowInterestLastChange: BigInt    # is only updated to the last event, event BorrowTaken and event BorrowRepaid. i.e. Per block interest isn't saved, since the blockchain also does not store this.
    totalBorrowInterest: BigInt         # adds together each round of borrowed asset, to record a cumulative amount, since it isn't stored anywhere in the smart contract (actual asset value, i.e. not a percentage)
    borrowInterestIndex: BigInt         # The users personal total return in borrowing this asset
    transactionHashes: [Bytes!]!        # this is for the app, it shows every tx that has happened
}


